# Scenario‚ÄëBased Jenkins Implementations üöÄ (Emoji Edition)

Below are practical Jenkins Pipeline patterns with concise explanations and ready‚Äëto‚Äëpaste snippets. üß©

---

## 1) Handle Long‚ÄëRunning Jobs with Timeouts ‚è±Ô∏è

**Scenario:** Automatically terminate a job if it exceeds a certain duration.

**Why:** Prevents hung builds and frees executors.

**Code:** Limits the **Build** stage to **10 minutes**.

```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                timeout(time: 1, unit: 'MINUTES') {
                    echo 'Building project...'
                    sh 'sleep 600' // Simulate a long-running task
                }
            }
        }
    }
}
```
Go to pipeline syntax, search for timeout and select prefered unit
---

## 2) Conditional Stage Execution Based on File Change üß†üìÅ

**Scenario:** Execute stages only when particular files are modified.

**Why:** Saves time by skipping irrelevant work.

**Code:** Runs tests only when `**/*.test.js` files changed.

```sh


```

```groovy
pipeline {
    agent any
    stages {
        stage('Checkout') {
            steps {
                git branch: 'main', url: 'https://github.com/your-repo/your-project.git'
            }
        }
        stage('Run Tests') {
            when {
                changeset "**/*.test.js" // Trigger stage if test files are modified
            }
            steps {
                echo 'Running tests...'
                sh 'npm test'
            }
        }
    }
}
```

Private-Repo

Steps
- Create Token and Github Debveloper settings
- Create jenkins credentials, use username and password, add user github username and add token as password
```sh
stages {
    stage('Checkout') {
      steps {
        git url: 'https://github.com/bernardofosu/Boardgame-In--dir-with-jenkins.git',
            branch: 'main',
            credentialsId: 'git-cred'
      }
    }

# or 

git branch: 'main', credentialsId: 'git-cred', url: 'https://github.com/bernardofosu/Boardgame-In--dir-with-jenkins.git'
```
Project
```sh
pipeline {
  agent {label "agent-1"}

  tools { 
    maven 'maven3'   // Jenkins > Manage Jenkins > Tools
    jdk   'jdk17'
  }

  stages {
    stage('Git Checkout') {
      steps {
        git url: 'https://github.com/bernardofosu/Boardgame-In--dir-with-jenkins.git',
            branch: 'main',
            credentialsId: 'git-cred'   // remove if repo is public
      }
    }

    // === Your requested example ===
    stage('Build') {
      steps {
        sh 'pwd; ls -la'                 // sanity: show workspace root
        dir('dir') {                     // cd $WORKSPACE/dir  (must match folder name)
          sh 'mvn -B -ntp clean package' // build using the pom.xml inside /dir
        }
      }
    }

    stage('Archive') {
      steps {
        // jar lives under dir/target after building inside dir()
        archiveArtifacts artifacts: 'dir/target/*.jar', fingerprint: true
      }
    }
  }
}
```

### By default Jenkins checks your repo out directly into the job‚Äôs workspace root.
So with your repo layout:
```sh
Boardgame-In--dir-with-jenkins/
‚îî‚îÄ dir/
   ‚îî‚îÄ pom.xml


after git ‚Ä¶ the files live at:

$WORKSPACE/dir      ‚úÖ  (default)
```

‚Äînot at $WORKSPACE/Boardgame-In--dir-with-jenkins/dir.

You only get an extra level (e.g. $WORKSPACE/Boardgame-In--dir-with-jenkins/dir) if you explicitly tell Jenkins to do so, for example by:

adding the ‚ÄúCheckout to a sub-directory‚Äù extension (aka RelativeTargetDirectory) in your checkout step, or

wrapping the checkout in dir('Boardgame-In--dir-with-jenkins') { git ‚Ä¶ }, or

configuring a custom workspace/subdir.

Quick way to verify in a build

Linux agent:
```sh
pipeline {
    agent {label "agent-1"}
    
    stages {
        stage ("Clone Repo"){
            steps {
                git url: 'https://github.com/bernardofosu/Boardgame-In--dir-with-jenkins.git',
                branch: 'main',
                credentialsId: 'git-cred'   // remove if repo is public
              }
        }
        stage('Where am I?') {
              steps {
                sh 'echo WORKSPACE=$WORKSPACE'
                sh 'pwd; ls -la'
                sh 'ls -la dir'
              }
           }
    }
}
```

Windows agent:
```sh
stage('Where am I?') {
  steps {
    bat 'echo WORKSPACE=%WORKSPACE%'
    bat 'cd & dir'
    bat 'dir dir'
  }
}
```
TL;DR
- Default: repo root ‚Üí $WORKSPACE, your folder ‚Üí $WORKSPACE/dir.
- Nested path only if you purposely check out to a subdirectory.


#### Why $WORKSPACE is .../workspace/examle-dir
Jenkins names the workspace after the job (here, your Pipeline job called examle-dir). It does not create a nested folder with the repo name. After checkout, your repo‚Äôs files are placed directly under $WORKSPACE, so your dir from GitHub ends up at:
```sh
$WORKSPACE/dir
```
#### Why files are owned by ubuntu:ubuntu
The Jenkins agent that ran this build is executing as the ubuntu user (e.g., you connected the node via SSH as ubuntu, or you installed Jenkins to run as that user). If you ran the agent as the jenkins service account, you‚Äôd see jenkins:jenkins ownership instead.

### If you want a subfolder with the repo name
Use a relative target directory (or wrap checkout in dir(...)):
```sh
pipeline {
  agent any
  options {
    skipDefaultCheckout(true)   // <- stop Jenkins from auto-checking out at root
  }

  stages {
    stage('Init (clean)') {
      steps {
        cleanWs()               // or: deleteDir()
      }
    }

    stage('Checkout into subfolder') {
      steps {
        checkout([$class: 'GitSCM',
          branches: [[name: '*/main']],
          userRemoteConfigs: [[
            url: 'https://github.com/bernardofosu/Boardgame-In--dir-with-jenkins.git',
            credentialsId: 'git-cred'   // remove if public
          ]],
          extensions: [[$class: 'RelativeTargetDirectory',
                        relativeTargetDir: 'Boardgame-In--dir-with-jenkins']]
        ])

        // sanity checks
        sh 'echo WORKSPACE=$WORKSPACE'
        sh 'ls -la'
        sh 'ls -la Boardgame-In--dir-with-jenkins'
      }
    }

    // (no build; just clone into subfolder as requested)
  }
}
```
Result: Only this structure remains
```sh
$WORKSPACE/
  Boardgame-In--dir-with-jenkins/
    .git
    dir/
```

If you ever want to build from that subfolder later, just wrap:
```sh
dir('Boardgame-In--dir-with-jenkins/dir') {
  sh 'mvn -B -ntp clean package'
}
```
[Jenkins: Checkout Into Subfolder & Maven Build](Jenkins%20Checkout%20Into%20Subfolder%20&%20Maven%20Build.md)

## 3) Post‚ÄëBuild Cleanup üßπ

**Scenario:** Clean workspace after a build to free disk space.

**Why:** Keeps agents tidy and prevents disk pressure.

**Code:** Always clean, regardless of status.

```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                echo 'Building project...'
                // Build logic
            }
        }
    }
    post {
        always {
            echo 'Cleaning up workspace...'
            cleanWs()
        }
    }
}
```
[Jenkins Workspace Cleanup](./Jenkins Workspace Cleanup.md)
---

## 4) Retry Failed Steps üîÅ

**Scenario:** Automatically retry a failing step.

**Why:** Flaky networks/services? Give them a second chance.

**Code:** Retry up to **3** times.

```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                retry(3) {
                    echo 'Attempting to build...'
                    sh 'exit 1' // Simulate a failure
                }
            }
        }
    }
}
```

---

## 5) Multi‚ÄëEnvironment Deployment Using Parameters üåé

**Scenario:** Choose Dev/QA/Prod at build time.

**Why:** One pipeline, multiple targets.

**Code:** Dropdown selects environment; deploy accordingly.

```groovy
pipeline {
    agent any
    parameters {
        choice(name: 'ENV', choices: ['Dev', 'QA', 'Prod'], description: 'Select the environment to deploy')
    }
    stages {
        stage('Build') {
            steps {
                echo "Building the application for environment: ${params.ENV}"
            }
        }
        stage('Deploy') {
            steps {
                script {
                    if (params.ENV == 'Dev') {
                        echo 'Deploying to Dev environment...'
                    } else if (params.ENV == 'QA') {
                        echo 'Deploying to QA environment...'
                    } else if (params.ENV == 'Prod') {
                        echo 'Deploying to Prod environment...'
                    }
                }
            }
        }
    }
}
```
[Jenkins Declarative Pipeline: if/else vs when {]()

---

## 6) Parallel Testing üèéÔ∏èüèéÔ∏èüèéÔ∏è

**Scenario:** Run multiple test suites in parallel.

**Why:** Reduce total CI time.

**Code:** Unit, Integration, and UI tests concurrently.

```groovy
pipeline {
    agent any
    stages {
        stage('Parallel Testing') {
            parallel {
                stage('Unit Tests') {
                    steps {
                        echo 'Running Unit Tests...'
                    }
                }
                stage('Integration Tests') {
                    steps {
                        echo 'Running Integration Tests...'
                    }
                }
                stage('UI Tests') {
                    steps {
                        echo 'Running UI Tests...'
                    }
                }
            }
        }
    }
}
```

---

## 7) Conditional Stages Based on Branch üåø

**Scenario:** Run stages only for certain branches.

**Why:** Tailor behavior for `main` vs. feature branches.

**Code:** Build on `main`, Test on `feature/*`.

```groovy
pipeline {
    agent any
    stages {
        stage('Checkout') {
            steps {
                git branch: '*/main', url: 'https://github.com/your-repo/your-project.git'
            }
        }
        stage('Build') {
            when { branch 'main' }
            steps { echo 'Building for the main branch...' }
        }
        stage('Test') {
            when { branch 'feature/*' }
            steps { echo 'Testing for a feature branch...' }
        }
    }
}
```

---

## 8) Archive and Publish Build Artifacts üì¶

**Scenario:** Save artifacts for download and traceability.

**Why:** Share outputs across jobs or with stakeholders.

**Code:** Archive and fingerprint a zip.

```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                echo 'Building the application...'
                sh 'touch build-artifact.zip'
            }
        }
        stage('Archive Artifacts') {
            steps {
                archiveArtifacts artifacts: 'build-artifact.zip', fingerprint: true
            }
        }
    }
}
```

---

### ‚úÖ Tips & Best Practices

* Use **`options { timeout(...) }`** at the pipeline level for global safety nets. ‚õëÔ∏è
* Pair **`retry`** with **`sleep`** backoffs to avoid hammering flaky services. üí§
* Add **`post { failure { ... } }`** notifications (Slack/Email) for visibility. üîî
* Keep workspaces clean to speed up checkouts and conserve disk. üßΩ

**Done!** Paste any snippet into your Jenkinsfile and tweak to taste. üç∞
